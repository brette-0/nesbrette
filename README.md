# `nesbrette`
---
The Nintendo Entertainment System is a historic console, it's 'aesthetic' used as the prototype of modern 'pixel games' and it's memorable shell used to captivate an archaic world of gaming. While most video game enjoyers have moved on many times to sucessor consoles, the NES/Famicom isn't friendless. With the development of Flashcarts and Emulators, a dedicated community of enthusiasts who have taken the console apart to work it like it has never been worked before.

When you write for a console like the NES, you write as for few other consoles. The NES' design demands the developer become aware with of it's hardware to a personal level. With this familiarity, many great things within the NES development world has been born - similarly, some used modern hardware as a means to super-enable the NES beyond its typical capacity.

However most of the great things within the world of NESDev do not come from modifying the console, apart from enabling expansion audio on non-japanese systems or enabling writing on the Famicom Disk System (FDS), most of the world of improvements comes from software.

#### Famistudio

Famistudio is a both a DAW composing tool desgined for many OS', it's also an audio driver supporting exports from the DAW to use with the main three NES assembly languages. Famistudio supports (as of writing this) Sunsoft 5B, VRC6, VRC6, Namco 163, MMC5, FDS and EPSM. EPSM is a special thing, as it's not a *real* NES audio chip but rather an external chip which uses an unused expansion slot on the NES. The 'EPSM' chip has been produced by a small company known as Muramasa Entertainment - their stocks typically drained quickly due to how sought after this chip is. 

#### *Libraries?*

The NES has libraries like any other programmable hardware does, although you might speculate that much of it is copyrighted or lost to time. The LibUltra microcode for the Nintendo 64 was concern enough when used in James Lamber's faithful recreation of the Valve game 'Portal' for the Nintendo 64 so much that Vale themselves forbid James to continue development. Unfortunately the damage had been done so migrating to LibDragon (the open source equivalent) was not an option.

The NES has libraries, `neslib` being the most common of all. But libraries are an interesting thing in this context. With C, you might include a library with the preprocessor and increase the amount of dynamically linked libraries associated with your binary, or you might statically compile creating a larger output but each equally executable on your modern hardware.

The NES does not, by default, come with an Operating System and therefore may only have it's games statically compiled or statically assembeled. Due to this, inclusion of libraries comes a dramatic cost on Program ROM. When developing in C, libraries are crucial for providing elementary functionality in order to maintain C-like standard lexis when programming.

#### So what does `nesbrette` do better?

`nesbrette` does not include anything left unused, any table or procedure will demand to be included via a seperate configuration. Should it be that said element is missing, `nesbrette` validation will provide you a detailed exception describing the asset you need, and where in docs you can find more information.

`nesbrette` uses cleverly designed macros to handle calling logic, deciding then and there if an `inline` solution is more optimal with optional overrides as macro parameters with pre-designed enums for ease of use. `nesbrette` uses an immense amount of lexical hierachy manipulation and preprocessor features to ensure no truly wasted cycles are produced.

`nesbrette` has it's own table generation code configurable by JSON file which is then processed by a Python script, the script allows total configuration of the table value's such as what banks they enter, their name's (with defaults) as well as the amount of items, the width of each items and any optional optimisations.

`nesbrette` documents everything, every feature implemented is configured by default at your ease - but should an issue arise, or you wish to squeeze every drop of opimisation from the library the documentations will describe the limitations, capacity and speediest route out. In fact, some features have optional tables designed to speed up the code at cost of more Program ROM.

#### How do I use it?

`nesbrette` is exclusively a `ca65` assembled library, targetting `6502x` (illegal instructions assmbled) and can be used for more than just the NES circumstantially. Some `nesbrette` features may use an `idtable` which allows the NES to perform operations with the values of its general purpose registers like never before possible with just a `6502x`.

When configuring your copy of `nesbrette`, you must first decide what tables you need. Consult the `table_generator.json`. The first hierarchy is a string for the output generated by the Python script, the second hierachy is the different kinds of table, the third hierachy is the parameters for said table. Each table type has its own parameters, so if you are unsure please check the documentation.

Next you need to declare your globals, to configure what globals you want enter `engine/global_includes.asm` to toggle what macros you do and do not want. Understand that macros are not affected by lexical hierarchy and their definition can only be controlled by `.macro` and `.undef`, `.undefine`.

All `nesbrette` macros include on an `.ifndef` basis, which should remove any assembler level errors, replacing them for a 'already included' warning which can be disabled should you choose, however, we simply suggest removing repeated includes.

Once you have decided on these, it is highly reccomended that you copy and paste the file `template/nesbrette_includes.asm` into a file called `/nesbrette_includes.asm` within the target scripts folder, be it lexically encapsulated or banked logic. Within this you can enable or disable assembled scripts for more complicated logic that are inappropriate as a macro.

At this point you have decided what features this lexically isolated module should have, now you will need to configure the final parameters being addreses. While each feature *can* be inline and therefore use address overrides, those that are not macros should *typically* be callable and therefore unless using Self-Modifing Code (SMC) should have a designated are in memory for its values.

For example, math operations *could* share result space for addition and subtraction as serial math operations could become more efficient. Likewise temporaries could overlap as their value is only important during call lifetime. Similarly, values may be by default absolute whereas your zero page may be empty enough to fit in some values for most commonly used methods - speeding up your application.

In order to modify addresses, copy and paste `templates/nesbrette_adresses.asm` and modify how you see fit, you may repeat this for `templates/nesbrette_constants.asm` to configure needed constants, this file also includes flags for when to use constant should it be that you opt to use constants selectively.

Finally at the end of all this, you perform an include like so
```
.scope "game_engine"
    .include "table_game_engine.asm"
    .include "constants_game_engine.asm"
    .include "addresses_game_engine.asm"
    .include "includes_game_engine.asm"
    ; script body
.enscope
```